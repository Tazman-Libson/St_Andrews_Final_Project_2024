"0","#mod is a list with the following elements:"
"0","#m: number of states (not an element of list)"
"0","#n: dimension of the multivariate gaussian (not an element of list)"
"0","#MEANS <- matrix (m x n) Mean. Each row is are the means for each state"
"0","#VARS <- matrix (m x n) Variances. Each row are the variances for each state"
"0","#CORR <- 3D array (n x n x m)  correlation matrices"
"0","#TPM <- matrix (m x m) one step transition probabilities "
"0","#ID <- vector (m) initial distribution "
"0",""
"0","###Natural Parameters to Working parameters function:"
"0","#Inputs:"
"0",""
"0","mvn.n2w <- function(mod, stationary){"
"0","  #Reparameterization for tpm:"
"0","  tpm <- mod$TPM"
"0","  m <- dim(tpm)[1]"
"0","  tpm <- log(tpm/diag(tpm)) #Rescale tpm values by the diagonals, then take log."
"0","  tpm <- as.vector(tpm[!diag(m)]) #turn into vector, but exclue diagonal values."
"0","  #Initial Distribution:"
"0","  if(stationary == F){"
"0","    id <- mod$ID"
"0","    id<-log(id[-1]/id[1]) #If model isn't stationary, rescale the "
"0","    #initial distribution similarly to the tpm"
"0","  }"
"0","  #correlation:"
"0","  corr <-mod$CORR"
"0","  corr <- mvn.ar_to_vec(corr) #turn array of into vector, only taking the upper diagonal of"
"0","  #each matrix in the array"
"0","  corr <- tan(corr*pi/2) #take tangent of the correlation values."
"0","  #variances:"
"0","  vars <- mod$VARS"
"0","  vars <- as.vector(vars) "
"0","  vars <- log(vars)"
"0","  #means (don't need reparam, just vectorization)"
"0","  mns <- as.vector(mod$MEANS)"
"0","  params <- c(tpm, corr, vars, mns)"
"0","  if(!stationary){"
"0","    params <- c(params, id)"
"0","  }"
"0","  return(params) #return a single vector of parameters. need a single vector"
"0","}"
"0",""
"0","mvn.w2n <- function(params, m, n, stationary){"
"0","  #Indices for the various parameters"
"0","  tpm_last <- (m*(m-1))"
"0","  corr_last <- tpm_last + (n*n - n*(n+1)/2)*m"
"0","  vars_last <- corr_last + m*n"
"0","  mns_last <- vars_last + m*n"
"0","  #Transistion Probability Matrix"
"0","  tpm <- params[1:tpm_last]"
"0","  TPM <- diag(m) "
"0","  TPM[!TPM] <- exp(tpm) #Taking exp to move back to normal parameters"
"0","  TPM <- TPM/apply(TPM,1,sum) # Divide by sum of row to ensure row sums to 1."
"0","  #Correlation Array:"
"0","  corr <- params[(tpm_last+1):corr_last]"
"0","  corr <- atan(corr)*2/pi #Take inverse tan to turn back to normal"
"0","  CORR <- mvn.vec_to_ar(corr, n, m) #Turn back into an array"
"0","  #Variance Matrix:"
"0","  vars <- params[(corr_last + 1):vars_last]"
"0","  vars <- exp(vars) #turn back into normal parameters using exp."
"0","  VARS <- matrix(vars, nrow = m, ncol  = n) #turn back into matrix"
"0","  #Means:"
"0","  means <- params[(vars_last+1):mns_last]"
"0","  MEANS <- matrix(means, nrow = m, ncol = n, byrow = F) #only need to turn back into matrix."
"0","  if(stationary){"
"0","    #If stationary, sets the initial distribution to the stationary distribution"
"0","    ID <- stat_dist(TPM)"
"0","  }else{"
"0","    #If not stationary, takes the last values and turns back to normal parameters"
"0","    id <- tail(params, n = (m-1))"
"0","    foo<-c(1,exp(id))"
"0","    ID<-foo/sum(foo)"
"0","  }"
"0","  return("
"0","    list("
"0","      MEANS = MEANS,"
"0","      CORR = CORR,"
"0","      VARS = VARS,"
"0","      TPM = TPM,"
"0","      ID = ID"
"0","    )"
"0","  )"
"0","}"
