lafact    <- apply(la,1,max)
lbfact    <- apply(lb,1,max)
for (i in 1:lenx)
{
foo      <- (exp(la[i,]-lafact[i])%*%mod$TPM)*exp(lb[i,]-lbfact[i])
foo      <- foo/sum(foo)
#if(i ==1){print(foo)}
dxc[i]  <- sum(Px[i,]%*%t(foo))
}
return(dxc)
}
mvn.pdf <- function(x,mod){
lenx         <- dim(x)[1]
m         <- dim(mod$TPM)[1]
dxc       <- matrix(NA,nrow=lenx,ncol=1)
Px        <- matrix(NA,nrow=lenx,ncol=m)
for (j in 1:lenx){ Px[j,] <- diag(mvn.p_matrix(mod, x[j,]))}
la        <- mvn.lforward(x,mod)
lb        <- mvn.lbackward(x,mod)
la        <- rbind(log(mod$ID),la)
lafact    <- apply(la,1,max)
lbfact    <- apply(lb,1,max)
for (i in 1:lenx)
{
foo      <- (exp(la[i,]-lafact[i])%*%mod$TPM)*exp(lb[i,]-lbfact[i])
foo      <- foo/sum(foo)
#if(i ==1){print(foo)}
dxc[i]  <- sum(Px[i,]%*%t(foo))
}
return(dxc)
}
qqnorm(mvn.cdf(tmatrix, nlm_mod))
hist(qqnorm(mvn.cdf(tmatrix, nlm_mod)))
hist(qnorm(mvn.cdf(tmatrix, nlm_mod)))
mvn.HMM_mllk <- function(parvec, X, m, n, stationary){
mod <- mvn.w2n(parvec, m, n, stationary)
if(!stationary){
mod$ID <- sapply(mod$ID, FUN = threshold)
}
print(mod)
tpm <- mod$TPM
t <- dim(X)[1] # number of observations
phi <- mod$ID * diag(mvn.p_matrix(mod, X[1,]))
l <- log(sum(phi)) #log likelihood
phi <- phi/sum(phi)
for(i in 2:t){
v <- phi %*% tpm * diag(mvn.p_matrix(mod, X[i,]))
u <- sum(v)
l <- l + log(u)
phi <- v/u #rescaled vector of forward probabilities
}
return(-l)
}
mvnlktest <- mvn.HMM_ml_mod_fit(returns_tmod, tmatrix)
mvnlktest
?nlm
mvn.HMM_mllk <- function(parvec, X, m, n, stationary){
mod <- mvn.w2n(parvec, m, n, stationary)
if(!stationary){
mod$ID <- sapply(mod$ID, FUN = threshold)
}
#print(mod)
tpm <- mod$TPM
t <- dim(X)[1] # number of observations
phi <- mod$ID * diag(mvn.p_matrix(mod, X[1,]))
l <- log(sum(phi)) #log likelihood
phi <- phi/sum(phi)
for(i in 2:t){
v <- phi %*% tpm * diag(mvn.p_matrix(mod, X[i,]))
u <- sum(v)
l <- l + log(u)
phi <- v/u #rescaled vector of forward probabilities
}
return(-l)
}
mvn.HMM_ml_mod_fit <- function(mod, data, stationary = T){
n <- dim(mod$CORR )[2]# number of variables for multivariate norm
m <- dim(mod$TPM)[1] # number of states
parvec <- mvn.n2w(mod, stationary)
#print(parvec)
#print( mvn.w2n(parvec, m, n, stationary))
fit <- nlm(mvn.HMM_mllk, parvec, X = data, n= n, m= m, stationary = stationary, steptol = 1e-5, print.level = 2)
#print(fit)
mod <- mvn.w2n(fit$estimate, m = m, n = n, stationary = stationary)
mod$minimum <- fit$minimum
mod$code <- fit$code
mod$iterations <- fit$iterations
return(mod)
}
mvnlktest <- mvn.HMM_ml_mod_fit(returns_tmod, tmatrix)
traceback()
mvn.HMM_ml_mod_fit <- function(mod, data, stationary = T){
n <- dim(mod$CORR )[2]# number of variables for multivariate norm
m <- dim(mod$TPM)[1] # number of states
parvec <- mvn.n2w(mod, stationary)
#print(parvec)
#print( mvn.w2n(parvec, m, n, stationary))
fit <- nlm(mvn.HMM_mllk, parvec, X = data, n= n, m= m, stationary = stationary, steptol = 1e-6, print.level = 2)
#print(fit)
mod <- mvn.w2n(fit$estimate, m = m, n = n, stationary = stationary)
mod$minimum <- fit$minimum
mod$code <- fit$code
mod$iterations <- fit$iterations
return(mod)
}
mvn.HMM_ml_mod_fit <- function(mod, data, stationary = T){
n <- dim(mod$CORR )[2]# number of variables for multivariate norm
m <- dim(mod$TPM)[1] # number of states
parvec <- mvn.n2w(mod, stationary)
#print(parvec)
#print( mvn.w2n(parvec, m, n, stationary))
fit <- nlm(mvn.HMM_mllk, parvec, X = data, n= n, m= m, stationary = stationary, steptol = 1e-7, print.level = 2)
#print(fit)
mod <- mvn.w2n(fit$estimate, m = m, n = n, stationary = stationary)
mod$minimum <- fit$minimum
mod$code <- fit$code
mod$iterations <- fit$iterations
return(mod)
}
mvnlktest <- mvn.HMM_ml_mod_fit(returns_tmod, tmatrix)
View(nlm_mod)
optim(mvn.n2w(returns_tmod), mvn.HMM_mllk, X = tmatrix, m = 3, n = 4, stationary = T)
optim(mvn.n2w(returns_tmod), mvn.HMM_mllk, X = tmatrix, m = 3, n = 4, stationary = T)
mvn.HMM_mllk <- function(parvec, X, m, n, stationary  = T){
mod <- mvn.w2n(parvec, m, n, stationary)
if(!stationary){
mod$ID <- sapply(mod$ID, FUN = threshold)
}
#print(mod)
tpm <- mod$TPM
t <- dim(X)[1] # number of observations
phi <- mod$ID * diag(mvn.p_matrix(mod, X[1,]))
l <- log(sum(phi)) #log likelihood
phi <- phi/sum(phi)
for(i in 2:t){
v <- phi %*% tpm * diag(mvn.p_matrix(mod, X[i,]))
u <- sum(v)
l <- l + log(u)
phi <- v/u #rescaled vector of forward probabilities
}
return(-l)
}
optim(mvn.n2w(returns_tmod), mvn.HMM_mllk, X = tmatrix, m = 3, n = 4, stationary = T)
mvn.HMM_mllk <- function(parvec, X, m, n, stationary){
mod <- mvn.w2n(parvec, m, n, stationary)
if(!stationary){
mod$ID <- sapply(mod$ID, FUN = threshold)
}
#print(mod)
tpm <- mod$TPM
t <- dim(X)[1] # number of observations
phi <- mod$ID * diag(mvn.p_matrix(mod, X[1,]))
l <- log(sum(phi)) #log likelihood
phi <- phi/sum(phi)
for(i in 2:t){
v <- phi %*% tpm * diag(mvn.p_matrix(mod, X[i,]))
u <- sum(v)
l <- l + log(u)
phi <- v/u #rescaled vector of forward probabilities
}
return(-l)
}
optim(mvn.n2w(returns_tmod, T), mvn.HMM_mllk, X = tmatrix, m = 3, n = 4, stationary = T)
optim_test <- optim(mvn.n2w(returns_tmod, T), mvn.HMM_mllk, X = tmatrix, m = 3, n = 4, stationary = T)
?optim
optim_test <- optim(mvn.n2w(returns_tmod, T), mvn.HMM_mllk, X = tmatrix, m = 3, n = 4, stationary = T)
optim_test
optim_test <- optim(mvn.n2w(returns_tmod, T), fn = mvn.HMM_mllk, X = tmatrix, m = 3, n = 4, stationary = T)
optim_test
optim_test <- optim(mvn.n2w(returns_tmod, T), fn = mvn.HMM_mllk, X = tmatrix, m = 3, n = 4, stationary = T, control = list(maxit = 100))
optim_test <- optim(mvn.n2w(returns_tmod, T), fn = mvn.HMM_mllk, X = tmatrix, m = 3, n = 4, stationary = T, control = list(maxit = 1000))
optim_test
optim_test <- optim(mvn.n2w(returns_tmod, T), fn = mvn.HMM_mllk, X = tmatrix, m = 3, n = 4, stationary = T, control = list(maxit = 10000))
optim_test
optim_test <- optim(mvn.n2w(returns_tmod, T), fn = mvn.HMM_mllk, X = tmatrix, m = 3, n = 4, stationary = T, control = list(maxit = 50000))
mvn.HMM_mllk <- function(parvec, X, m, n, stationary){
mod <- mvn.w2n(parvec, m, n, stationary)
if(!stationary){
mod$ID <- sapply(mod$ID, FUN = threshold)
}
print(mod)
tpm <- mod$TPM
t <- dim(X)[1] # number of observations
phi <- mod$ID * diag(mvn.p_matrix(mod, X[1,]))
l <- log(sum(phi)) #log likelihood
phi <- phi/sum(phi)
for(i in 2:t){
v <- phi %*% tpm * diag(mvn.p_matrix(mod, X[i,]))
u <- sum(v)
l <- l + log(u)
phi <- v/u #rescaled vector of forward probabilities
}
return(-l)
}
mvn.HMM_mllk <- function(parvec, X, m, n, stationary){
mod <- mvn.w2n(parvec, m, n, stationary)
if(!stationary){
mod$ID <- sapply(mod$ID, FUN = threshold)
}
if(runif(1) < 0.1){print(mod)}
tpm <- mod$TPM
t <- dim(X)[1] # number of observations
phi <- mod$ID * diag(mvn.p_matrix(mod, X[1,]))
l <- log(sum(phi)) #log likelihood
phi <- phi/sum(phi)
for(i in 2:t){
v <- phi %*% tpm * diag(mvn.p_matrix(mod, X[i,]))
u <- sum(v)
l <- l + log(u)
phi <- v/u #rescaled vector of forward probabilities
}
return(-l)
}
optim_test <- optim(mvn.n2w(returns_tmod, T), fn = mvn.HMM_mllk, X = tmatrix, m = 3, n = 4, stationary = T, control = list(maxit = 50000))
mvn.HMM_mllk <- function(parvec, X, m, n, stationary){
mod <- mvn.w2n(parvec, m, n, stationary)
if(!stationary){
mod$ID <- sapply(mod$ID, FUN = threshold)
}
if(runif(1) < 0.1){print(mod)}
tpm <- mod$TPM
t <- dim(X)[1] # number of observations
phi <- mod$ID * diag(mvn.p_matrix(mod, X[1,]))
l <- log(sum(phi)) #log likelihood
phi <- phi/sum(phi)
for(i in 2:t){
v <- phi %*% tpm * diag(mvn.p_matrix(mod, X[i,]))
u <- sum(v)
l <- l + log(u)
phi <- v/u #rescaled vector of forward probabilities
}
if(runif(1) < 0.1){print(-1)}
return(-l)
}
optim_test <- optim(mvn.n2w(returns_tmod, T), fn = mvn.HMM_mllk, X = tmatrix, m = 3, n = 4, stationary = T, control = list(maxit = 50000))
mvn.HMM_mllk <- function(parvec, X, m, n, stationary){
mod <- mvn.w2n(parvec, m, n, stationary)
if(!stationary){
mod$ID <- sapply(mod$ID, FUN = threshold)
}
if(runif(1) < 0.1){print(mod)}
tpm <- mod$TPM
t <- dim(X)[1] # number of observations
phi <- mod$ID * diag(mvn.p_matrix(mod, X[1,]))
l <- log(sum(phi)) #log likelihood
phi <- phi/sum(phi)
for(i in 2:t){
v <- phi %*% tpm * diag(mvn.p_matrix(mod, X[i,]))
u <- sum(v)
l <- l + log(u)
phi <- v/u #rescaled vector of forward probabilities
}
if(runif(1) < 0.1){print(-l)}
return(-l)
}
optim_test <- optim(mvn.n2w(returns_tmod, T), fn = mvn.HMM_mllk, X = tmatrix, m = 3, n = 4, stationary = T, control = list(maxit = 50000))
optim_test
optim_mod <- mvn.w2n(optim_test$par, 3, 4, T)
qqnorm(mvn.cdf(tmatrix, optim_mod))
hist(qnorm(mvn.cdf(tmatrix, nlm_mod)))
hist(qnorm(mvn.cdf(tmatrix, optim_mod)))
var(qnorm(mvn.cdf(tmatrix, optim_mod)))
qnorm(mvn.cdf(tmatrix, optim_mod))
a <- qnorm(mvn.cdf(tmatrix, optim_mod))
var(a)
optim_mod
#Testing Backward Probabilities:
log(exp(log(exp(mvn.lbackward(tmatrix, nlm_mod))*exp(mvn.lforward(mod = nlm_mod, x = tmatrix))))%*%c(1,1,1))
mvn.cdf(tmatrix, optim_mod)
mvn.p_matrix(optim_mod, tmatrix[52,])
#Function for state_dependent distribution probability matrix
#Inputs:
#mod <- list as described above
#X <- vector of legnth n with the observations at a single time
#Outputs:
#an m x m diagnonal matrix with the marginal probability for each state-dependent distribtion
mvn.p_matrix <- function(mod, X){
mvn <- function(m){
sig <- diag(mod$VARS[m,]) %*% mod$CORR[,,m] %*% diag(mod$VARS[m,])
#print('sig')
#print(sig)
means <- mod$MEANS[m,]
#print('means')
#print(means)
return(dmvnorm(X, mean = means, sigma = sig, checkSymmetry = F))
}
m <- dim(mod$TPM)[1]
probs <- lapply(1:m, mvn)
return(diag(probs))
}
mvn.p_matrix(optim_mod, tmatrix[52,])
tmatrix[52,]
optim_mod
tmatrix[52,]
mvn.lforward(tmatrix,optim_mod)
mvn.lbackward(tmatrix,optim_mod)
#Testing Backward Probabilities:
log(exp(log(exp(mvn.lbackward(tmatrix, nlm_mod))*exp(mvn.lforward(mod = nlm_mod, x = tmatrix))))%*%c(1,1,1))
#Testing Backward Probabilities:
log(exp(log(exp(mvn.lbackward(tmatrix, optim_mod))*exp(mvn.lforward(mod = optim_mod, x = tmatrix))))%*%c(1,1,1))
#Function for state_dependent distribution probability matrix
#Inputs:
#mod <- list as described above
#X <- vector of legnth n with the observations at a single time
#Outputs:
#an m x m diagnonal matrix with the marginal probability for each state-dependent distribtion
mvn.p_matrix <- function(mod, X){
mvn <- function(m){
sig <- diag(mod$VARS[m,]) %*% mod$CORR[,,m] %*% diag(mod$VARS[m,])
print('sig')
print(sig)
means <- mod$MEANS[m,]
print('means')
print(means)
return(dmvnorm(X, mean = means, sigma = sig, checkSymmetry = F))
}
m <- dim(mod$TPM)[1]
probs <- lapply(1:m, mvn)
return(diag(probs))
}
mvn.p_matrix(optim_mod, tmatrix[52,])
sig <- diag(optim_mod$VARS[2,]) %*% optim_mod$CORR[,,2] %*% diag(optim_mod$VARS[2,])
print('sig')
print(sig)
means <- optim_mod$MEANS[2,]
print('means')
print(means)
return(dmvnorm(X, mean = means, sigma = sig, checkSymmetry = F))
return(dmvnorm(tmatrix[52,], mean = means, sigma = sig, checkSymmetry = F))
sig <- diag(optim_mod$VARS[2,]) %*% optim_mod$CORR[,,2] %*% diag(optim_mod$VARS[2,])
print('sig')
print(sig)
means <- optim_mod$MEANS[2,]
print('means')
print(means)
dmvnorm(tmatrix[52,], mean = means, sigma = sig, checkSymmetry = F)
tmatrix[52,]
mvn.cdf(tmatrix, optim_mod)
optim_test
mvn.cumul_vec <- function(mod, X){
mvn <- function(m){
sig <- diag(mod$VARS[m,]) %*% mod$CORR[,,m] %*% diag(mod$VARS[m,])
means <- mod$MEANS[m,]
return(pmvnorm(lower = X, upper = Inf, mean = means, sigma = sig))
}
m <- dim(mod$TPM)[1]
probs <- sapply(1:m,  FUN =mvn)
return(probs)
}
mvn.cdf <- function(x,mod){
lenx         <- dim(x)[1]
m         <- dim(mod$TPM)[1]
dxc       <- matrix(NA,nrow=lenx,ncol=1)
Px        <- matrix(NA,nrow=lenx,ncol=m)
for (j in 1:lenx){ Px[j,] <- mvn.cumul_vec(mod, x[j,])}
#print(Px)
la        <- mvn.lforward(x,mod)
lb        <- mvn.lbackward(x,mod)
la        <- rbind(log(mod$ID),la)
lafact    <- apply(la,1,max)
lbfact    <- apply(lb,1,max)
for (i in 1:lenx)
{
foo      <- (exp(la[i,]-lafact[i])%*%mod$TPM)*exp(lb[i,]-lbfact[i])
foo      <- foo/sum(foo)
#if(i ==1){print(foo)}
dxc[i]  <- sum(Px[i,]%*%t(foo))
}
return(dxc)
}
qqnorm(mvn.cdf(tmatrix, optim_mod))
#Function for state_dependent distribution probability matrix
#Inputs:
#mod <- list as described above
#X <- vector of legnth n with the observations at a single time
#Outputs:
#an m x m diagnonal matrix with the marginal probability for each state-dependent distribtion
mvn.p_matrix <- function(mod, X){
mvn <- function(m){
sig <- diag(mod$VARS[m,]) %*% mod$CORR[,,m] %*% diag(mod$VARS[m,])
#print('sig')
#print(sig)
means <- mod$MEANS[m,]
#print('means')
#print(means)
return(dmvnorm(X, mean = means, sigma = sig, checkSymmetry = F))
}
m <- dim(mod$TPM)[1]
probs <- lapply(1:m, mvn)
return(diag(probs))
}
qqnorm(mvn.cdf(tmatrix, optim_mod))
hist(qnorm(mvn.cdf(tmatrix, optim_mod)))
var(qnorm(mvn.cdf(tmatrix, optim_mod)))
mean(qnorm(mvn.cdf(tmatrix, optim_mod)))
#Function to generate infinite lower and upper bounds except for a given index, where it
#replaces the observed value.
#obs_index is location of obs
#obs is the observation
#n is the length of the vector
gen_bounds <- function(obs_index, obs, n){
lower <- rep(Inf, n)
lower[obs_index] <- obs
return(lower)
}
#Function to generate infinite lower and upper bounds except for a given index, where it
#replaces the observed value.
#obs_index is location of obs
#obs is the observation
#n is the length of the vector
gen_lbound <- function(obs_index, obs, n){
lower <- rep(Inf, n)
lower[obs_index] <- obs
return(lower)
}
gen_lbound(2, 0.1, 10)
#Function to generate infinite lower and upper bounds except for a given index, where it
#replaces the observed value.
#obs_index is location of obs
#obs is the observation
#n is the length of the vector
gen_lbound <- function(obs_index, obs, n){
lower <- rep(-Inf, n)
lower[obs_index] <- obs
return(lower)
}
gen_lbound(2, 0.1, 10)
?sapply
#Function which provides the seperate probabilities of each individual return for each state.
#Returns a matrix
#mod is a model, X is a full observation (vector of legnth n)
mvn.cumul_mat <- function(mod, X){
m <- dim(mod$TPM)[1]
n <- dim(mod$CORR)[2]
output <- matrix(nrow = m, ncol = n)
prob_fun <- function(i){
prob_sub_fun <- function(m){
sig <- diag(mod$VARS[m,]) %*% mod$CORR[,,m] %*% diag(mod$VARS[m,])
means <- mod$MEANS[m,]
return(pmvnorm(lower = gen_lbound(i, X[i], n), upper = Inf, mean = means, sigma = sig))
}
probs <- sapply(1:m,  FUN =prob_sub_fun)
}
probs <- sapply(1:n,  FUN =prob_fun, simplify = "matrix")
return(probs)
}
mvn.cumul_mat(optim_mod, tmatrix[1,])
mvn.cumul_mat(optim_mod, tmatrix[2,])
mvn.cumul_mat(optim_mod, tmatrix[4,])
mvn.cumul_mat(optim_mod, tmatrix[5,])
mvn.cdf_new <- function(x,mod){
lenx         <- dim(x)[1]
m         <- dim(mod$TPM)[1]
n <- dim(mod$CORR)[2]
dxc       <- matrix(NA,nrow=lenx,ncol=n)
Px        <- array(NA,dim = c(m, n, lenx))
for (j in 1:lenx){ Px[,,j] <- mvn.cumul_mat(mod, x[j,])}
return(Px)
la        <- mvn.lforward(x,mod)
lb        <- mvn.lbackward(x,mod)
la        <- rbind(log(mod$ID),la)
lafact    <- apply(la,1,max)
lbfact    <- apply(lb,1,max)
for (i in 1:lenx)
{
foo      <- (exp(la[i,]-lafact[i])%*%mod$TPM)*exp(lb[i,]-lbfact[i])
foo      <- foo/sum(foo)
#if(i ==1){print(foo)}
dxc[i,]  <- sum(Px[i,]%*%t(foo))
}
return(dxc)
}
mvn.cdf_new(tmatrix[1:5, ], optim_mod)
mvn.cumul_mat(optim_mod, tmatrix[5,])
mvn.cumul_mat(optim_mod, tmatrix[5,])[,2]
mvn.cdf_new <- function(x,mod){
lenx         <- dim(x)[1]
m         <- dim(mod$TPM)[1]
n <- dim(mod$CORR)[2]
dxc       <- matrix(NA,nrow=lenx,ncol=n)
Px        <- array(NA,dim = c(m, n, lenx))
for (j in 1:lenx){ Px[,,j] <- mvn.cumul_mat(mod, x[j,])}
la        <- mvn.lforward(x,mod)
lb        <- mvn.lbackward(x,mod)
la        <- rbind(log(mod$ID),la)
lafact    <- apply(la,1,max)
lbfact    <- apply(lb,1,max)
for (i in 1:lenx)
{
foo      <- (exp(la[i,]-lafact[i])%*%mod$TPM)*exp(lb[i,]-lbfact[i])
foo      <- foo/sum(foo)
for(j in 1:n){
dxc[i,j]  <- sum(Px[,j,i]%*%t(foo))
}
}
return(dxc)
}
mvn.cdf_new(tmatrix[1:5, ], optim_mod)
mvn.cdf_new(tmatrix, optim_mod)
pseudoresids <- mvn.cdf_new(tmatrix, optim_mod)
hist(qnrom(pseudoresids[,2]))
hist(qnorm(pseudoresids[,2]))
hist(qnorm(pseudoresids[,3]))
hist(qnorm(pseudoresids[,4]))
hist(qnorm(pseudoresids[,1]))
var(qnorm(pseudoresids[,1]))
mean(qnorm(pseudoresids[,1]))
hist(qnorm(pseudoresids[,2]))
mean(qnorm(pseudoresids[,1:4]))
hist(qnorm(pseudoresids[,1:4]))
hist(pseudoresids[,1:4])
save.image("C:/Users/tazma/Documents/GitHub/St_Andrews_Final_Project_2024/Pseudoresiduals of Multivariate Gaussian Financial HMMs/workspace.RData")
